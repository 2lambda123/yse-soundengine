/*
  ==============================================================================

    sound.h
    Created: 28 Jan 2014 11:50:15am
    Author:  yvan

  ==============================================================================
*/

#ifndef SOUND_H_INCLUDED
#define SOUND_H_INCLUDED

#include "classes.hpp"
#include "headers/defines.hpp"
#include "headers/types.hpp"
#include "headers/enums.hpp"
#include "utils/vector.hpp"

namespace YSE {

  /**
      A sound object is needed for every kind of sound you want to use. Sounds can use
      audio files (wav, ogg, flac, and more on some systems) or can be linked to a DSP
      source. Sounds can be mono, stereo or multichannel.

      If a soundfile is streamed, it will use its own soundbuffer. Otherwise YSE will
      create a new buffer only if needed or re-use and existing buffer if another file
      with the same filename has already been loaded. Unloading of soundfiles and clearing
      memory is done internally: when a buffer is not used by any sound any more, it will be 
      flagged for deletion.
  */

  class API sound {
  public:
    /** Create a filebased sound and register it with the soundsystem. Other functions will not work
        as long as a sound hasn't been created. In debug mode, an assertion will be called if
        you try to do so. On the other hand, create cannot be called twice. If you need 
        another sound, create a new sound object.

        @param fileName   This can be an absolute path or something relative to the 
                          working directory.
        @param channel    The sound channel you want to attach the sound to. Sounds can
                          be moved to other channels at any time. If no channel is provided,
                          the sound will be added to the global channel (mainMix).
        @param loop       Use true to loop this sound continuously. If not provided, the sound
                          will not loop.
        @param volume     The initial volume to play this sound. This should be a value between
                          0.0 and 1.0. Default is 1.0.
        @param streaming  Whether or not this sound should be streamed. Defaults to false.
                          Streaming is mainly intended for big audio files that are only used
                          by a single sound. When a sound is used repeatedly, avoid streaming.
    */
    sound& create(const char * fileName, channel * ch = NULL, Bool loop = false, Flt volume = 1.0f, Bool streaming = false);
      
    /** Create a DSP sound and register it with the soundsystem. In contrast to a filebased sound,
        the source if this soundobject will be generated by a dspSourceObject you provide yourself.
     
        @param dsp      You provide a reference to an object for sound generation. Such objects must
                        be based on dspSourceOBject.
        @param channel  The channel to attach the sound to. If no channel is provided, the sound will
                        be added to the global channel (mainMix).
        @param volume   The volume at which to start playing this sound.
    */
    sound& create(DSP::dspSourceObject &  dsp, channel * ch = NULL, Flt volume = 1.0f);

    /** 
     Set the position of this sound in the virtual space.
    */
    sound& setPosition(const Vec &v);
      
    /**
     Get the current position of this sound.
    */
    Vec getPosition();
      
    /**
        This is only useful for multichannel sounds. If a sound has more than one channel, 
        the channels can be spread out over the stereo or surround field. 
        This defines how much space there is between the position of the channels.
    */
    sound& setSpread(Flt value);
    
    /**
        Returns how much a multichannel sound is spread out in space.
    */
    Flt getSpread();
    
    /**
        The speed at which a sound plays back alters it's pitch. The actual speed will also 
        be affected by velocity (doppler effect) unless doppler is disabled.
     
        Internally this value will never be set entirely to zero, because that would result 
        in static output that might damage speakers.
     
        A negative value is also possible and will result in the sound being played backwards.
        Streaming sounds will not be played backwards though, because this would require an
        insane amount of disk activity. (This might change later on because SSD disks do not
        suffer from this.
    */
    sound& setSpeed(Flt  value);
      
    /** Returns the current speed at which the sound is playing.
    */
    Flt getSpeed();
      
    /**
     Set the 'size' of the sound. This defines from how far away in the virtual space a sound
     will be heard.
    */
    sound& setSize(Flt  value);
    
    /** Returns the current size of the sound, ie. how far away it will be heard.
    */
    Flt getSize();
      
    /** Set if this sound is looping or one-shot. Should be obvious, right?
    */
    sound& setLooping(Bool value);
    
    /** If this sound is looping or one-shot.
    */
    Bool isLooping();

    /**
     Sets the volume for this sound. You can use this as a fader by supplying a time value.
     
     @param value The target volume.
     @param time  If supplied, do a smooth change to the target volume over 'time' milliseconds. (Default is 0.)
    */
    sound& setVolume(Flt value, UInt time = 0);
      
    /**
     Get the current volume. This can be different from the current target volume if a time has been supplied
     when setVolume() is used.
    */
    Flt getVolume();
    
    /**
     Fadeout the over 'time'  milliseconds. Then stop the sound.
    */
    sound& fadeAndStop(UInt time);

    /**
     Play this sound.
    */
    sound& play();
      
    /**
     Return true if the sound is currently playing.
    */
    Bool isPlaying();
      
    /**
     Pause this sound. Starting it again will continue from the current position.
    */
    sound& pause();
    
    /**
     Return true if the sound is currently paused.
    */
    Bool isPaused();
    
    /**
      Stop this sound. The position in the source file will be reset to zero. If started again, the sound
      will start from the beginning.
    */
    sound& stop();
    
    /**
     Return true if the sound is currently stopped.
    */
    Bool isStopped();
      
    /**
     Pauses the sound if playing, continues if paused, starts if stopped.
    */
    sound& toggle();
      
    /**
     Restart a sound from the beginning, even if its current position was someplace else.
    */
    sound& restart();
      
    /**
     Set the current plahing position in the file. Don't get confused here with setPosition,
     which sets the position in the virtual space where the sound will be rendered.
     
     @param value The new position in samples. Must be between 0 and the length of the file.
    */
    sound& setTime(Flt value);
    
    /**
     Get the current playing position in the file. Don't get confused here with getPosition,
     which gets the position in the virtual space where the sound will be rendered.
     
     @return the current position in samples.
    */
    Flt  getTime();
      
    /**
     Get the length of the file.
     
     @return the length in samples.
    */
    UInt getLength(); // sound length in samples

    /**
     Make a sound relative to the Listener() object. This is YSE's alternative to '2D' sounds.
     Relative sounds can still move, but they move along with the player. By default this is
     how Gui sounds and music are used in most gaming sound setups. 
     
     But there's more: by making the sounds relative instead of fixed, you can still to other
     stuff with them. The sound can still be moving.
    */
    sound& setRelative(Bool value);
    
    /**
     See if a sound is relative to the Listener() object.
    */
    Bool isRelative();
      
    /**
     Enable / disable doppler for this sound.
     @see System().setDopplerScale() for global doppler behaviour
    */
    sound& setDoppler(Bool value);
      
    /**
     See if doppler is enabled for this sound
    */
    Bool getDoppler();
    
    /**
    This is a convenience function equal to setRelative(true).setPosition(0).setDoppler(false);
    */
    sound& set2D(Bool value);
      
      
    Bool is2D();
    
    /**
     Will be true if the sound is streamed (from disk or over the network) instead of played
     from memory.
    */
    Bool isStreaming();
    
    /**
     Will be true if the sound is ready to be played (or if it is already playing). This can take a while
     if a sound is not streaming because loading sounds into memory is done in a seperate time as not to
     obstruct the audio callback.
     Not that it is not needed to wait for this result to be true before you can use most other functions 
     with this sound. For instance, if you use the play() function, the sound will be played when it
     becomes ready.
    */
    Bool isReady();
      
    /**
     Returns true if the sound is valid. Sounds are invalid if the create function is not called, if
     the create function failed for some reason (for instance if the file doesn't exist) or when you've
     manually released the file.
    */
    Bool isValid();

    /**
     This will enable sound occlusion for this sound. Remember to setup an occlusion callback function
     in System() first.
    */
    sound& setOcclusion(Bool value); 
    
    /**
     Returns true if sound occlusion is active for this sound.
    */
    Bool getOcclusion(); 
      
    sound& attachDSP(DSP::dspObject & value); DSP::dspObject * dsp(); // attach a dsp object to this sound

    sound();
   ~sound();
  private:
    sound& releaseImplementation(); // release sound 

    INTERNAL::soundImplementation *pimpl;

    // flags and values are used to update a sound so to not get in the way of the dsp processing
    // (this avoids having a critical zone or a lot of atomics in the implementation)
    aBool flagPos      ; aVec  posValue       ;
    aBool flagSpread   ; aFlt  spread         ;
    aBool flagFade     ; aUInt fadeAndStopTime;
    aBool flagVolume   ; aFlt  volumeValue    ;
                         aUInt volumeTime     ;

    aBool flagPitch    ; aFlt  pitch          ;
    aBool flagSize     ; aFlt  size           ;
    aBool flagLoop     ; aBool loop           ;
    aBool flagTime     ; aFlt  time           ;
    
    aBool relative     ;
    aBool doppler      ;
    aBool pan2D        ;  
    aBool occlusion    ; 
    
    aBool streaming    ; 
    aUInt length       ;
    
    std::atomic<SOUND_INTENT> intent; // what we want the sound to do
    std::atomic<SOUND_STATUS> status; // what it is currently doing

    friend class INTERNAL::soundImplementation;

  };

}




#endif  // SOUND_H_INCLUDED
